---
title: Spring（学习笔记）
date: 2023/1/3
cover: https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13704/wallhaven-x68r2l.jpg
tags:
- ssm
- 框架
categories: SSM
---

## 初识Spring

###  Spring简介

- Spring是一个为简化企业级开发而生的**开源框架**。
- Spring是一个**IOC(DI)**和**AOP**容器框架。
- IOC全称：Inversion of Control【控制反转】
  - 将对象【万物皆对象】控制权交给Spring
- DI全称：(Dependency Injection)：依赖注入
- AOP全称：Aspect-Oriented Programming，面向切面编程
- 官网：https://spring.io/

### 搭建Spring框架

- 导入jar包

  ```xml
  <!--导入spring-context-->
  <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context</artifactId>
      <version>5.3.1</version>
  </dependency>
  <!--导入junit4.12-->
  <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.12</version>
      <scope>test</scope>
  </dependency>
  ```

- 编写核心配置文件

  - 配置文件名称：**applicationContext.xml【beans.xml或spring.xml】**

  - 配置文件路径：**src/main/resources**

  - 示例代码

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    
        <!-- 将对象装配到IOC容器中-->
    	<!-- 这里的id是唯一的，不能有重复，不然获取bean对象的时候就会报错-->    
        <bean id="stuZhenzhong" class="com.atguigu.spring.pojo.Student">
            <property name="stuId" value="101"></property>
            <property name="stuName" value="zhenzhong"></property>
        </bean>
        
    </beans>
    ```

- 使用核心类库

  ```java
  public void testSpring(){
          //使用spring之前
          //Student student = new Student();
          //使用spring之后
          ApplicationContext ioc = new ClassPathXmlApplicationContext("applicationContext.xml");
          Student stu = (Student) ioc.getBean("stu");
          System.out.println(stu);
      }
  ```

### Spring特性

- 非侵入式：基于Spring开发的应用中的对象可以不依赖于Spring的API。
  - 例如我们使用servlet的时候需要导入servlet需要的类，并且要实现他的方法，而spring则不需要
- 容器：Spring是一个容器，因为它包含并且管理应用对象的生命周期。
- 组件化：Spring实现了使用简单的组件配置组合成一个复杂的应用。在 Spring 中可以使用XML和Java注解组合这些对象。
- 一站式：在IOC和AOP的基础上可以整合各种企业应用的开源框架和优秀的第三方类库（实际上Spring 自身也提供了表述层的SpringMVC和持久层的JDBCTemplate）。

### SPring中getBean的三种方式

- getBean(String beanId): 通过beanId获取对象

  - 不足：需要强制类型转换，不灵活

    ```java
    ApplicationContext ioc = new ClassPathXmlApplicationContext("applicationContext.xml");
            //方式一获取
            Student stu = (Student) ioc.getBean("stu");
            System.out.println(stu);
    ```

- getBean(Class clazz)：通过Class方式获取对象

  - 不足：容器中有多个相同类型bean的时候，会报如下错误：

    ![image-20221228113540763](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13704/image-20221228113540763.png)

    ```java
    Student stu = ioc.getBean(Student.class);
    System.out.println(stu);
    ```

- **getBean(String beanId,Clazz clazz)：通过beanId和Class获取对象**

  - 推荐使用

> 注意：框架默认都是通过无参构造器，帮助我们创建对象。
>
> 所以：如提供对象的构造器时，一定添加无参构造器

- 属性
  - id：bean的唯一标识
  - class：定义bean的类型【class全类名】
- 子标签
  - property：为对象中属性赋值【set注入】
    - name属性：设置属性名称
    - value属性：设置属性数值

## Spring底层IOC实现

> IOC：将对象的控制器反转给Spring

#### BeanFactory与ApplicationContexet

- BeanFactory：IOC容器的基本实现，是Spring内部的使用接口，是面向Spring本身的，不是提供给开发人员使用的。
- ApplicationContext：BeanFactory的子接口，提供了更多高级特性。面向Spring的使用者，几乎所有场合都使用ApplicationContext而不是底层的BeanFactory。

### 图解IOC类的结构

![image-20220326090009379](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13704/image-20220326090009379.png)

BeanFactory：Spring底层IOC实现【面向Spring框架】

- ...
  - **ApplicationContext**：面向程序员
    - **ConfigurableApplicationContext：提供关闭或刷新容器对象方法**
      - ...
        - **ClassPathXmlApplicationContext：基于类路径检索xml文件**
        - **AnnotationConfigApplicationContext**：基于注解创建容器对象
        - FileSystemXmlApplicationContext：基于文件系统检索xml文件

## Spring依赖注入数值问题【重点】

### 字面量数值

- 数据类型：基本数据类型及包装类、String
- 语法：value属性或value标签

### CDATA区

- 语法：\<![CDATA[]]>
- 作用：在xml中定义特殊字符时，使用CDATA区 

### 外部已声明bean及级联属性赋值

- 语法：ref

  - 前提要在bean的外部在声明一个外部bean

- 注意：级联属性更改数值会影响外部声明bean【ref赋值的是引用】

- 示例代码

  ```xml
  <!--外部已声明bean-->
  <bean id="dept1" class="spring.pojo.Dept">
          <property name="deptId" value="1"/>
          <property name="deptName" value="研发部"/>
      </bean>
  <!--测试外部bean引用-->
      <bean id="li" class="spring.pojo.Employee">
          <property name="id" value="1"/>
          <property name="lastName" value="zhao"/>
          <property name="email" value="123@qq"/>
          <property name="salary" value="10"/>
  <!-- 当我们赋值的对象如果不是基本数据类型，也不是包装类或者String的话这时候就不能使用字面量数值，需要外部声明bean -->
          <property name="dept" ref="dept1"/>
          <property name="dept.deptName" value="财务部"/>
      </bean>
  ```

![image-20220326102128821](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13704/image-20220326102128821.png)

### 内部bean

- 概述

  - 内部类：在一个类中完整定义另一个类，当前类称之为内部类
  - 内部bean：在一个bean中完整定义另外一个bean，当前bean称之为内部bean
  - 作用：可以不用像外部bean一样因为级联属性的赋值，而导致属性发生更改
  - 注意：内部bean不能通过ioc容器获得。

- 示例代码

  ```xml
  <bean id="liu" class="spring.pojo.Employee">
          <property name="id" value="101"/>
          <property name="lastName" value="qq"/>
          <property name="email" value="1231@qq.com"/>
          <property name="salary" value="101"/>
          <property name="dept" >
              <bean class="spring.pojo.Dept">
                  <property name="deptId" value="1"/>
                  <property name="deptName" value="人事部"/>
              </bean>
          </property>
      </bean>
  ```

### 集合

- List

  ```xml
  <!--    测试集合-->
      <bean id="dept2" class="spring.pojo.Dept">
          <property name="deptId" value="2"/>
          <property name="deptName" value="管理部"/>
          <property name="employees">
              <list>
                  <ref bean="li"/>
                  <ref bean="liu"/>
              </list>
          </property>
      </bean>
  <!--    测试list及list的提取 注意util的名称空间引入的时候要正确-->
      <util:list id="empList">
          <ref bean="li"/>
          <ref bean="liu"/>
      </util:list>
      <bean id="dept4" class="spring.pojo.Dept">
          <property name="deptId" value="4"/>
          <property name="deptName" value="运营部"/>
          <property name="employees" ref="empList"/>
      </bean>
  ```

- Map

  ```xml
  <!--    测试map-->
      <bean id="dept5" class="spring.pojo.Dept">
          <property name="deptId" value="5"/>
          <property name="deptName" value="采购部门"/>
          <property name="empMap">
              <map>
                  <entry>
                      <key>
                          <value>1</value>
                      </key>
                      <ref bean="li"/>
                  </entry>
                  <entry key="2" value-ref="liu"/>
              </map>
          </property>
      </bean>
      <!--测试map提取-->
      <util:map id="map">
          <entry>
              <key>
                  <value>1</value>
              </key>
              <ref bean="li"/>
          </entry>
          <entry key="2" value-ref="liu"/>
      </util:map>
      <bean id="dept6" class="spring.pojo.Dept">
          <property name="deptId" value="6"/>
          <property name="deptName" value="后勤部门"/>
          <property name="empMap" ref="map"/>
      </bean>
  ```

  

## Spring依赖注入方式 【基于XML】

> 为属性赋值的方法
>
> - 通过构造器赋值
> - 通过set方法赋值
> - 反射

### set注入

```xml
<bean id="stu" class="spring.pojo.Student">
    <property name="stuId" value="1"/>
    <property name="stuName" value="赵凯诺"/>
</bean>
```

- 语法：通过\<property>标签

### 构造器注入

```xml
<bean id="stu2" class="spring.pojo.Student">
    <constructor-arg name="stuId" value="101"></constructor-arg>
    <constructor-arg name="stuName" value="超人"></constructor-arg>
</bean>
```

- 语法：通过\<constructor-arg>标签，这里的参数数量要与构造器定义的数量一致

###  p名称空间注入

> 导入名称空间：xmlns:p="http://www.springframework.org/schema/p"

```xml
</bean>
<bean id="stu1" class="spring.pojo.Student" p:stuId="11" p:stuName="xxx">
</bean>
```

语法：\<bean p:xxx>(他的底层逻辑也是set注入)



## Spring管理第三方的bean

### Spring管理druid步骤

- 导入jar包

  ```xml
  <!--导入druid的jar包-->
          <dependency>
              <groupId>com.alibaba</groupId>
              <artifactId>druid</artifactId>
              <version>1.1.10</version>
          </dependency>
          <!--导入mysql的jar包-->
          <dependency>
              <groupId>mysql</groupId>
              <artifactId>mysql-connector-java</artifactId>
              <version>5.1.37</version>
  <!--            <version>8.0.26</version>-->
          </dependency>
  ```

- 编写db.properties配置文件

  

- 编写applicationContext.xml（来管理druid）

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <beans xmlns="http://www.springframework.org/schema/beans"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:context="http://www.springframework.org/schema/context"
         xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">
  <!--加载外部属性文件-->
      <context:property-placeholder location="classpath:db.properties"/>
  <!--    装配数据源-->
      <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
          <property name="driverClassName" value="${db.driverClassName}"/>
          <property name="url" value="${db.url}"/>
          <property name="username" value="${db.username}"/>
          <property name="password" value="${db.password}"/>
       </bean>
  </beans>
  ```

- 测试

  ```java
  @org.junit.Test
      public void testDruid() throws SQLException {
          ApplicationContext ioc = new ClassPathXmlApplicationContext("applicationContext_durid.xml");
          DruidDataSource dataSource = ioc.getBean("dataSource", DruidDataSource.class);
          DruidPooledConnection connection = dataSource.getConnection();
          System.out.println(connection);
      }
  ```

## Spring中FactoryBean

### Spring中两种bean

- 一种是普通bean
- 另一种是工厂bean【FactoryBean】
  - 作用：如需我们程序员参数到bean的创建时，使用FactoryBean
  - 特点：工厂bean设置的类型可以和返回的类型不一样，其返回的类型是通过该工厂bean的getObject方法指定。

### FactoryBean使用步骤

- 实现FactoryBean接口

- 重写方法【三个】

  ```java
  public class MyFactoryBean implements FactoryBean {
      @Override
      public Dept getObject() throws Exception {
          Dept dept = new Dept(1, "研发部门");
          return dept;
      }
  
      @Override
      public Class<?> getObjectType() {
          return Dept.class;
      }
  
      @Override
      public boolean isSingleton() {
          return false;
      }
  }
  ```

- 装配工厂bean

  ```xml
  <bean id="myFactoryBean" class="spring.FactoryBean.MyFactoryBean"></bean>
  ```

- 测试

  ```java
  @org.junit.Test
      public void testFactory(){
          ApplicationContext ioc = new ClassPathXmlApplicationContext("applicationContext_factory.xml");
          Dept myFactoryBean = ioc.getBean("myFactoryBean", Dept.class);
          System.out.println(myFactoryBean);
      }
  ```

## Spring中bean的作用域

### 语法

- 在bean标签中添加属性：scope属性即可

### 四个作用域

- singleton【默认值】：单例【在容器中只有一个对象，不管从容器中获取几次拿到的都是同一个对象】

  - 创建对象时机：创建容器对象时，创建对象执行

    ![image-20221229113406701](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13704/image-20221229113406701.png)

- prototype：多例【在容器中有多个对象，拿到的都是不同的对象】

  - 对象创建时机：getBean()方法被调用时，创建对象执行

    ![image-20221229113601940](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13704/image-20221229113601940.png)

- request：请求域

  - 当前请求有效，离开请求域失效
  - 当前请求：**URL不变即为当前请求**

- session：会话域

  - 当前会话有效，离开当前会话失效
  - 当前会话：**当前浏览器不关闭不更换即为当前对话**

## Spring中bean的生命周期

### bean的生命周期

① 通过构造器或工厂方法创建bean实例

② 为bean的属性设置值和对其他bean的引用

③ 调用bean的初始化方法

④  bean可以使用了

⑤ **当容器关闭时**，调用bean的销毁方法

代码示例

```java
public void initStudent(){
        System.out.println("3.初始化方法");
    }
    public void destroy(){
        System.out.println("5.bean被销毁");
    }
```

```xml
<bean id="student" class="spring.pojo.Student" init-method="initStudent" destroy-method="destroy">
        <property name="id" value="1"/>
        <property name="stuName" value="zhan"/>
</bean>
```

```java
public void TestLife(){
        ConfigurableApplicationContext context = new ClassPathXmlApplicationContext("applicationContext_life.xml");
        Student student = context.getBean("student", Student.class);
        System.out.println("4.使用student"+student);
        context.close();
    }
```

### bean的后置处理器

- 作用：在调用初始化方法前后对bean进行额外的处理。
- 实现：
  - 实现BeanPostProcessor接口
  - 重写方法
    - postProcessBeforeInitialization(Object, String)：在bean的初始化之前执行
    - postProcessAfterInitialization(Object, String)：在bean的初始化之后执行
  - 在容器中装配后置处理器

  - 注意：装配后置处理器会为**当前容器中每个bean**均装配，不能为局部bean装配后置处理器

### 添加后置处理器后bean的生命周期

① 通过构造器或工厂方法创建bean实例

② 为bean的属性设置值和对其他bean的引用

postProcessBeforeInitialization(Object, String)：在bean的初始化之前执行

③ 调用bean的初始化方法

postProcessAfterInitialization(Object, String)：在bean的初始化之后执行

④  bean可以使用了

⑤ **当容器关闭时**，调用bean的销毁方法

## Spring中的自动装配【基于XML】

### Spring中两种装配方式

- 手动装配
- 自动装配

### Spring自动装配的语法及规则

- 在bean标签中添加属性：Autowire即可

  - byName：对象中属性名称与容器中的beanId进行匹配，如果属性名与beanId数值一致，则自动装配成功

    ![image-20221230095945853](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13704/image-20221230095945853.png)

  - byType：对象中的**属性的类型**与容器中的**class**进行匹配，**如果类型相同且唯一则匹配成功**

    - 匹配0个：未装配
    - 匹配多个，会报错

    ![image-20221230100614833](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13704/image-20221230100614833.png)

- 注意：基于XML方式的自动装配，只能装配非字面量数值

- 总结

  - 基于xml自动装配，底层使用set注入
  - 最终：不建议使用byName，byType，**建议使用注解方式自动装配**

## Spring中注解【非常重要】

### 使用注解将对象装配到IOC容器中

> 约定：约束>配置【**注解>XML**】>代码
>
> 位置：在类上面标识
>
> 注意：
>
> - Spring本身不区分四个注解【四个注解本质是一样的都是@Component】,提供四个注解的目的只有一个：提高代码的可以读性
> - 只用注解装配对象，默认将类名首字母小写作为beanId
> - 可以使用value属性，设置beanId;当注解中只使用一个value属性时，value关键字可以省略

- ​	装配对象四个注解
  - @Component：装配**普通组件**到IOC容器
  - @Repository：装配**持久化层组件**到IOC容器
  - @Service：装配**业务逻辑层组件**到IOC容器
  - @Controller：装配**控制层|表示层组件**到IOC容器

- 使用注解步骤

  - 导入相关jar包【spring-context】

  - 开启组件扫描【默认扫描，当钱包及其子包都会扫描】

    ```xml
    <context:component-scan base-package="spring"/>
    ```

  - 使用注解标识组件

### 使用注解装配对象中属性【自动装配】

- **@Autowired注解**

  - 作用：自动装备对象中属性

  - 装配位置：要装配属性的上方

  - 装配原理：反射机制

  - 装配方式

    - **先按照byType进行匹配**

      - 匹配1个：匹配成功，正常使用

      - 匹配0个：

        - 默认【@Autowired(**required=true**)】报错

          ```java
          /*expected at least 1 bean which qualifies as autowire candidate. 	Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}
          */
          ```

        - @Autowired(**required=false**)，不会报错

      - 匹配多个

        - **再按照byName进行唯一筛选**

          - 筛选成功【对象中属性名称==beanId】,正常使用

          - 筛选失败【对象中属性名称!=beanId】,报如下错误:

            ```java
            //expected single matching bean but found 2: deptDao,deptDao2
            ```

            还是按照类型匹配重复的错误，报错

  - @Autowired中required属性

    - true：表示被标识的属性**必须装配数值**，如未装配，**会报错**。
    - false：表示被标识的属性**不必须装配数值**，如未装配，**不会报错**。

- @Qualifier

  - 作用：配合@Autowired一起使用，将**设置beanId名称装配到属性中**（指定固定的benaId进行装配）
  - 注意：不能单独使用，需要与@Autowired一起使用

- @Value

  - 作用：装配对象中的属性（只能装配字面量值，为bean对象的字面量属性进行初始化，后面可以改）

## Spring中组件扫描

### 默认使用情况

```xml
<!--    开启组件扫描
        base-package：设置扫描注解包名【当前包及其子包】
-->
<context:component-scan base-package="spring"></context:component-scan>
```

### 包含扫描

注意：

- 使用包含扫描之前，必须设置use-default-filters="false"【关闭当前包及其子包的扫描】
- type
  - annotation：设置被扫描**注解**的全类名
  - assignable：设置被扫描**实现类**的全类名

```xml
<context:component-scan base-package="spring" use-default-filters="false">
      <context:include-filter type="annotation" expression="org.springframework.stereotype.Repository"/>
      <context:include-filter type="annotation" expression="org.springframework.stereotype.Service"/>
      <context:exclude-filter type="assignable" expression="spring.controller.DeptController"/>
   </context:component-scan>
```

### 排除扫描

```xml
<context:component-scan base-package="spring">
      <context:exclude-filter type="assignable" expression="spring.controller,DeptController"/>
</context:component-scan>
```

## Spring完全注解开发【0配置】

### 完全注解开发步骤

1. 创建配置类

2. 在class上面添加注解

   - @Configuration：标识当前类是一个配置类，作用：代替XML配置文件
   - @ComponentScan：设置组件扫描当前包及其子包

3. 使用AnnotationConfigApplicationContext容器对象

4. 代码示例

   ```java
   @Configuration
   @ComponentScan(basePackages = "spring")
   public class SpringConfig {
   }
   ```

   ```java
   public void test0XML(){
           ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);
           DeptServiceImp deptServiceImp = context.getBean("deptServiceImp", DeptServiceImp.class);
           DeptController deptController = context.getBean("deptController", DeptController.class);
           System.out.println(deptController);
       }
   ```




## Spring集成junit4

### 集成步骤

1. 导入jar包

   - spring-test-5.3.1.jar

     ```xml
     <dependency>
                 <groupId>org.springframework</groupId>
                 <artifactId>spring-test</artifactId>
                 <version>5.3.1</version>
                 <scope>test</scope>
             </dependency>
     ```

2. 指定Spring的配置文件的路径

   - 【@ContextConfiguration】

3. 指定Spring环境下运行Junit4的运行器

   - @RunWith

4. 代码示例

   ```java
   @ContextConfiguration(locations = "classpath:applicationContext.xml")
   @RunWith(SpringJUnit4ClassRunner.class)
   public class TestJunit {
       @Autowired
       private DeptServiceImp deptServiceImp;
       @Test
       public void test(){
           deptServiceImp.add(new Dept());
       }
   }
   ```

## AOP前奏

### 代理模式

- 代理模式：我们需要做一件事情，又不期望自己亲力亲为，此时，就可以找一个代理【中介】

- 我们【目标对象】与中介【代理对象】不能相互转换，因为是平级的关系

  ![image-20220328152852821](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13704/image-20220328152852821.png)

###  为什么需要代理【程序中】

- 需求：实现【加减乘除】计算器类
  
- 在加减乘除方法中，添加日志功能【在计算之前，记录日志。在计算之后，显示结果。】
  
- 实现后发现问题如下

  - 日志代码**比较分散**，可以提取日志类

  - 日志代码**比较混乱**，日志代码【非核心业务代码】与加减乘除方法【核心业务代码】书写一处

    ![image-20221231101558720](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13704/image-20221231101558720.png)

- 总结：在核心业务代码中，**需要添加日志功能，但不期望在核心业务代码中书写日志代码**。

  - 此时：使用代理模式解决问题【**先将日志代码横向提取到日志类中，再动态织入回到业务代码中**】

### 手动实现动态代理环境

- 实现方式
  - 基于接口实现动态代理： **JDK动态代理**				
  - 基于继承实现动态代理： **Cglib**、Javassist动态代理
- 实现动态代理关键步骤
  - 一个类：**Proxy**
    - 概述：Proxy代理类的基类【类似Object】
    - 作用：newProxyInstance()：创建代理对象
  - 一个接口：InvocationHandler
    - 概述：实现【动态织入效果】关键接口
    - 作用：invoke()，执行invoke()实现动态织入效果

### 手动实现动态代理关键步骤

> 注意：代理对象与实现类【目标对象】是“兄弟”关系，不能相互转换

- 创建类【为了实现创建代理对象工具类】

- 提供属性【目标对象：实现类】

- 提供方法【创建代理对象】

- 提供有参构造器【避免目标对为空】

  ```java
  public class MyProxy {
  
      /**
       * 目标对象【目标客户】
       */
      private Object target;
  
      public MyProxy(Object target){
          this.target = target;
      }
  
      /**
       * 获取目标对象的，代理对象
       * @return
       */
      public Object getProxyObject(){
          Object proxyObj = null;
  
          /**
              类加载器【ClassLoader loader】,目标对象类加载器
              目标对象实现接口：Class<?>[] interfaces,目标对象实现所有接口
              InvocationHandler h
           */
          ClassLoader classLoader = target.getClass().getClassLoader();
          Class<?>[] interfaces = target.getClass().getInterfaces();
          //创建代理对象
          proxyObj = Proxy.newProxyInstance(classLoader, interfaces, new InvocationHandler() {
              //执行invoke()实现动态织入效果
              @Override
              public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                  //获取方法名【目标对象】
                  String methodName = method.getName();
                  //执行目标方法之前，添加日志
                  MyLogging.beforeMethod(methodName,args);
                  //触发目标对象目标方法
                  Object rs = method.invoke(target, args);
                  //执行目标方法之后，添加日志
                  MyLogging.afterMethod(methodName,rs);
                  return rs;
              }
          });
          return proxyObj;
      }
  
  //    class invocationImpl implements InvocationHandler{
  //    }
  
  }
  ```

  ```java
  	@Test
      public void testBeforeAop(){
  
  //        int add = calc.add(1, 2);
  //        System.out.println("add = " + add);
  
          //目标对象
          Calc calc = new CalcImpl();
          //代理工具类
          MyProxy myProxy = new MyProxy(calc);
          //获取代理对象
          Calc calcProxy = (Calc)myProxy.getProxyObject();
          //测试
  //        int add = calcProxy.add(1, 2);
          int div = calcProxy.div(2, 1);
  
      }
  ```

## Spring中AOP【重点】

### AspectJ框架【AOP框架】

- AspectJ是Java社区里最完整最流行的AOP框架。
- 在Spring2.0以上版本中，可以使用基于AspectJ注解或基于XML配置的AOP。

#### 使用AspectJ步骤

1. 添加jar包支持

   ```xml
   <!--        添加AspectJ-->
   <!--spirng-aspects的jar包-->
   <dependency>
       <groupId>org.springframework</groupId>
       <artifactId>spring-aspects</artifactId>
       <version>5.3.1</version>
   </dependency>
   ```

2. 配置文件

   - 开启组件扫描
   - 开启AspectJ注解支持

   ```xml
   <context:component-scan base-package="AOP"/>
   <aop:aspectj-autoproxy/>
   ```

3. 将日志类上面添加注解

   - @Component：将当前类标识为一个组件
   - @Aspect：将当前类标识为**切面类**【非核心业务提取类】

4. 将日志类中的方法中添加**通知注解**

   - @Before

   ```java
   import java.util.Arrays;
   @Component      //将当前类标识为一个组件
   @Aspect         //将当前类标识为【切面类】【非核心业务提取类】
   public class MyLogging {
       @Before(value = "execution( public int AOP.imp.CalcImp.add(int , int))")
       public static void beforeMethod(JoinPoint joinPoint){
           Object[] args = joinPoint.getArgs();
           String methodName = joinPoint.getSignature().getName();
           System.out.println("===>Calc中"+methodName+"方法"+",参数"+ Arrays.toString(args));
       }
   
       public static void afterMethod(String methodName,Object rs){
           System.out.println("===>Calc中"+methodName+"方法"+"结果:"+rs);
       }
   }
   ```

5. 测试

   ```java
   @Test
       public void testBefore(){
           ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
           Calc calc = context.getBean("calc", Calc.class);
           calc.add(1,2);
       }
   ```

###  Spring中AOP概述

- AOP：Aspect-Oriented Programming，面向切面编程【面向对象一种补充】【一种横向的扩展】
  - 优势：
    - 解决代码**分散问题**
    - 解决代码**混乱问题**
- OOP：Object-Oriented Programming，面向对象编程【一种纵向的扩展】

### Spring中AOP相关术语

1. 横切关注点：非核心业务代码【日志】，称之为横切关注点
2. **切面(Aspect)**：将横切关注点提取到类中，这个类称之为**切面类**
3. **通知(Advice)**：将横切关注点提取到类中之后，横切关注点更名为：通知
4. 目标(Target)：目标对象，指的是需要被代理的对象【实现类（CalcImpl）】
5. 代理(Proxy)：代理对象可以理解为：中介
6. 连接点(Joinpoint)：通知方法需要指定通知位置，这个位置称之为：连接点【通知之前】
7. **切入点(pointcut)**：通知方法需要指定通知位置，这个位置称之为：切入点【通知之后】

## AspectJ详解

### AspectJ中切入点表达式

- 语法：@Before(value=“execution(权限修饰符 返回值 包名.类名.方法名（参数类型) ”)

- 通配符

  - 【*】：

    ​		【*】:可以代表任意权限修饰符&返回值类型

    ​		【*】：可以代表任意包名、任意类名、任意方法名

    ![image-20221231150957545](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13704/image-20221231150957545.png)

  - 【..】：

    ​		【..】：代表任意参数类型及参数个数

    在实战中一般这样写，起码要知道包名和类名

    ![image-20221231151240881](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13704/image-20221231151240881.png)

- 重用切入点表达式

  1. 使用@PointCut注解，提出可重用的切入点表达式

     ```java
     @Pointcut("execution(* AOP.imp.CalcImp.*(..))")
         public void myPointcut(){
         }
     ```

  2. 使用方法名()引入切入点表达式

     ```
     @Before(value = "myPointcut()")
     ```

### Aspect中JoinPoint对象

- JoinPoint

- 作用：

  - 获取方法名称

    ```java
    //joinPoint.getSignature()获取方法签名【方法签名=方法名+方法参数】
    //获取方法名称
    String methodName =joinPoint.getSignature().getName();
    ```

  - 获取参数

    ```java
    Object[] args = joinPoint.getArgs();
    ```

### AspectJ中通知

- 前置通知

  - 语法：@Before

  - 执行时机：指定方法**执行之前**执行【如目标方法中有异常也会执行】

    - 指定方法：切入点表达式设置位置

      - 示例代码

      ```java
      @Pointcut("execution(* AOP.imp.CalcImp.*(..))")
          public void myPointcut(){
          }
      @Before(value = "myPointcut()")
          public  void beforeMethod(JoinPoint joinPoint){
              Object[] args = joinPoint.getArgs();
              String methodName = joinPoint.getSignature().getName();
              System.out.println("===>Calc中"+methodName+"方法"+",参数"+ Arrays.toString(args));
          }
      ```

- 后置通知

  - 语法：@After

  - 执行时机：指定方法**执行之后**执行【如目标方法中有异常也会执行】

    - 示例代码

    ```java
    @Pointcut("execution(* AOP.imp.CalcImp.*(..))")
        public void myPointcut(){
        }
    @After("execution(* AOP.imp.CalcImp.*(..))")
        public void afterMethod(JoinPoint joinPoint){
            String name = joinPoint.getSignature().getName();
            System.out.println("===>Calc中"+name+"方法");
        }
    ```

- 返回通知

  - 语法：@AfterReturning

  - 执行时机：指定方法返回结果时执行【如目标方法中有异常，会执行】

  - 注意事项：@AfterReturing中returning属性与入参参数名一致

  - 返回通知再后置通知之前执行

    - 示例代码

      ```java
      @AfterReturning(value = "myPointcut()",returning = "rs")
          public void afterReturning(JoinPoint joinPoint,Object rs){
              System.out.println("===>Calc中"+joinPoint.getSignature().getName()+"方法"+"结果是"+rs);
          }
      ```

- 异常通知

  - 语法：@AfterThrowing

  - 执行时机：指定方法出现异常时执行，【如目标方法中无异常，不执行】

  - 注意事项：@AfterThrowing中的throwing属性与入参参数名一致

    ```java
    @AfterThrowing(value = "myPointcut()",throwing = "ex")
    public void afterThrowing(JoinPoint joinPoint,Exception ex){
        System.out.println("===>Calc中"+joinPoint.getSignature().getName()+"方法"+"异常"+ex);
    }
    ```

- 总结

  - 无异常：前置通知==>返回通知==>后置通知
  - 有异常：前置通知==>异常通知==>后置通知

- 环绕通知【前四个通知整合】
  - 语法：@Around

  - 作用：整合前四个通知

  - 注意：参数中必须使用ProceedingJoinPoint，因为他是通过proceed（）方法去调度目标方法形成环绕通知

  - 示例代码

    ```java
    @Pointcut("execution(* AOP.imp.CalcImp.*(..))")
        public void myPointcut(){
        }
    @Around(value = "myPointcut()")
        public Object around(ProceedingJoinPoint pre){
            Object[] args = pre.getArgs();
            String methodName = pre.getSignature().getName();
            Object rs = null;
            try {
                //前置通知
                System.out.println("===>Calc中"+methodName+"方法"+",参数"+ Arrays.toString(args));
                rs = pre.proceed();
                //返回通知
                System.out.println("===>Calc中"+methodName+"方法"+"结果是"+rs);
            } catch (Throwable ex) {
                ex.printStackTrace();
    //            异常通知
                System.out.println("===>Calc中"+methodName+"方法"+"异常"+ex);
            }finally {
                //后置通知
                System.out.println("===>Calc中"+methodName+"方法执行完毕，参数："+ Arrays.toString(args));
            }
            return rs;
        }
    ```

### 定义切面优先级

- 语法:@Order(value=index)

  - index是int类型，默认值是int的最大值

  - 数值越小，优先级越高【一般使用正整数】

  - 示例代码

    ```java
    @Component
    @Aspect
    @Order(value = 1)
    
    public class MyVaildData {
        @Before("MyLogging.myPointcut()")
        public void vail(){
            System.out.println("===>检验数值");
        }
    }
    ```

### 基于XML方式配置AOP

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd">

    <!--配置计算器实现类-->
    <bean id="calculator" class="Aop.imp.CalImp"></bean>

    <!--配置切面类-->
    <bean id="loggingAspect" class="Aop.LoggingAspect"></bean>

    <!--AOP配置-->
    <aop:config>
        <!--配置切入点表达式-->
        <aop:pointcut id="pointCut"
                      expression="execution(* AOP.imp.CalcImp.*(..))"/>
        <!--配置切面-->
        <aop:aspect ref="loggingAspect">
            <!--前置通知-->
            <aop:before method="beforeAdvice" pointcut-ref="pointCut"></aop:before>
            <!--返回通知-->
            <aop:after-returning method="returningAdvice" pointcut-ref="pointCut" returning="result"></aop:after-returning>
            <!--异常通知-->
            <aop:after-throwing method="throwingAdvice" pointcut-ref="pointCut" throwing="e"></aop:after-throwing>
            <!--后置通知-->
            <aop:after method="afterAdvice" pointcut-ref="pointCut"></aop:after>
            <!--环绕通知-->
            <aop:around method="aroundAdvice" pointcut-ref="pointCut"></aop:around>
        </aop:aspect>
    </aop:config>
</beans>
```

## Spring中JdbcTemplate

### JdbcTemplate简介

- Spring提供的**JdbcTemplate**是一个小型持久化层框架，简化Jdbc代码。
  - Mybatis是一个半自动化的ORM持久化层框架

### JdbcTemplate基本使用

- 导入jar包

  ```xml
  <!--spring-context-->
  <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-context</artifactId>
      <version>5.3.1</version>
  </dependency>
  <!--spring-orm-->
  <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-orm</artifactId>
      <version>5.3.1</version>
  </dependency>
  <!--导入druid的jar包-->
  <dependency>
      <groupId>com.alibaba</groupId>
      <artifactId>druid</artifactId>
      <version>1.1.10</version>
  </dependency>
  <!--导入mysql的jar包-->
  <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>8.0.26</version>
  </dependency>
  <!--junit-->
  <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.12</version>
      <scope>test</scope>
  </dependency>
  ```
  
- 编写配置文件

  - db.properties：设置连接数据库属性

  - applicationContext.xml【spring配置文件】

    - 加载外部属性文件
    - 装配数据源【DataSources】
    - 装配JdbcTemplate

  - 示例代码

    ```xml
    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:context="http://www.springframework.org/schema/context"
           xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">
    <!--    - 加载外部属性文件-->
    <!--    - 装配数据源【DataSources】-->
    <!--    - 装配JdbcTemplate-->
        <context:property-placeholder location="classpath:db.properties"/>
        <bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource">
            <property name="driverClassName" value="${db.driverClassName}"/>
            <property name="url" value="${db.url}"/>
            <property name="username" value="${db.username}"/>
            <property name="password" value="${db.password}"/>
         </bean>
        <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
            <property name="dataSource" ref="dataSource"/>
        </bean>
    </beans>
    ```

### JdbcTemplate的常用API

> JdbcTemplate默认：自动提交事务

- jdbcTemplate.**update**(String sql,Object... args)：通用的**增删改**方法

- jdbcTemplate.**batchUpdate**(String sql,List<Object[]> args)：通用**批处理增删改**方法

- jdbcTemplate.**queryForObject**(String sql,Class clazz,Object... args)：查询**单个数值**（Class clazz,，你需要返回的参数类型）

  - String sql = "select  count(1)  from tbl_xxx";

- jdbcTemplate.**queryForObject**(String sql,RowMapper<T> rm,Object... args)：查询**单个对象**

  - String sql = "select  col1,col2...  from tbl_xxx";

- jdbcTemplate.**query**(String sql,RowMapper<T> rm,Obejct... args)：查询**多个对象**

- 示例代码

  ```JAVA
  @Test
      public void test(){
          ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
          JdbcTemplate jdbcTemplate = context.getBean("jdbcTemplate", JdbcTemplate.class);
          //增
  //        String sql = "insert into tbl_dept (dept_name) values(?)";
  //        jdbcTemplate.update(sql,"人事部2");
          //删
  //        String sql = "delete from tbl_dept where dept_id = ?";
  //        jdbcTemplate.update(sql,4);
          //改
  //        String sql = "update tbl_dept set dept_name = ? where dept_id = ?";
  //        jdbcTemplate.update(sql,"研发部2",1);
          //批量增
          /**
          String sql = "insert into tbl_employee(last_name,email,salary,dept_id) values(?,?,?,?)";
          List<Object[]> list = new ArrayList<>();
          list.add(new Object[]{"li","123@",100.0,1});
          list.add(new Object[]{"li2","123@",1003.0,12});
          list.add(new Object[]{"li3","123@",1002.0,12});
          list.add(new Object[]{"li5","123@",1001.0,13});
          jdbcTemplate.batchUpdate(sql,list);
           */
          //测试查询、
          //查询单个数值
  //        String sql = "select count(*) from tbl_employee";
  //        Integer count = jdbcTemplate.queryForObject(sql, Integer.class);
  //        System.out.println("员工数量："+count);
          //查询单个对象
          //要创建RowMapper对象
          /**
          RowMapper<Employee> rowMapper = new BeanPropertyRowMapper<>(Employee.class);
          String sql = "select id,last_name,email,salary from tbl_employee where id = ?";
          Employee employee = jdbcTemplate.queryForObject(sql, rowMapper, 1);
          System.out.println(employee);
           */
          //查询多个结果返回多个对象
          RowMapper<Employee> rowMapper = new BeanPropertyRowMapper<>(Employee.class);
          String sql = "select id,last_name,email,salary from tbl_employee";
          List<Employee> maps = jdbcTemplate.query(sql,rowMapper);
          for (Employee map : maps) {
              System.out.println(map);
          }
      }
  ```

###  使用JdbcTemplate搭建Service&Dao层

- Service层依赖Dao层

- Dao层依赖JdbcTemplate

- 示例代码

  ```JAVA
  @Repository
  public class DeptImp implements DeptDao {
      @Autowired
      @Qualifier("jdbcTemplate")
      private JdbcTemplate jdbcTemplate;
      @Override
      public List<Dept> findAll() {
          String sql = "select dept_id,dept_name from tbl_dept";
          RowMapper<Dept> rowMapper = new BeanPropertyRowMapper<>(Dept.class);
          List<Dept> query = jdbcTemplate.query(sql, rowMapper);
          return query;
      }
  }
  
  //
  @Service
  public class DeptServiceImp implements DeptService {
      @Autowired
      @Qualifier("deptImp")
      private DeptImp deptImp;
      @Override
      public List<Dept> findAll() {
         return deptImp.findAll();
      }
  }
  ```


## Spring声明式事务管理

> 回顾事务
>
> 1. 事务四大特征【ACID】
>    - 原子性
>    - 一致性
>    - 隔离性
>    - 持久性
> 2. 事务三种行为
>    - 开启事务：connection.setAutoCommit(false)
>    - 提交事务：connection.commit()
>    - 回滚事务：connection.rollback()

### spring中支持事务管理

- 编程式事务管理【传统事务管理】

  1) 获取数据库连接Connection对象

  2) 取消事务的自动提交【开启事务】

  3) **执行操作**

  4) 正常完成操作时手动提交事务

  5) 执行失败时回滚事务

  6) 关闭相关资源

  - 不足：
    - 事务管理代码【非核心业务】与核心业务代码相耦合
      - 事务管理代码分散
      - 事务管理代码混乱

- **声明式事务管理【使用AOP管理事务】**

  - 先横向提取【事务管理代码】，再动态织入

### 使用声明式事务管理

> 不用事务管理代码，发现：同一个业务中，会出现局部成功及局部失败的现象【不正常】

- 添加支持【AspectJ的jar包】

  ```xml
  <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-aspects</artifactId>
      <version>5.3.1</version>
  </dependency>
  ```

- 编写配置文件

  - **配置事务管理器**

  - **开启事务注解支持**

    ```XML
    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:context="http://www.springframework.org/schema/context"
           xmlns:tx="http://www.springframework.org/schema/tx"
           xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/context
           https://www.springframework.org/schema/context/spring-context.xsd
           http://www.springframework.org/schema/tx
           http://www.springframework.org/schema/tx/spring-tx.xsd">	
     <!--  配置事务管理器-->
        <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
            <property name="dataSource" ref="dataSource"/>
        </bean>
    
        <!-- 开启事务注解支持
           transaction-manager默认值：transactionManager-->
        <tx:annotation-driven transaction-manager="transactionManager"/>
    ```

- 在需要事务管理的业务方法上，添加注解**@Transactional**

  ```JAVA
  public class BookShopServiceImp implements BookShopService {
      @Autowired
      @Qualifier("bookShopDao")
      private BookShopDaoImp bookShopDaoImp;
  
      @Override
      @Transactional
      public void purchase(String username, String isbn) {
          //查看价格
          Integer bookPriceByIsbn = bookShopDaoImp.findBookPriceByIsbn(isbn);
          //修改库存
          bookShopDaoImp.updateBookStock(isbn);
          //修改价格
          bookShopDaoImp.updateUserAccount(username,bookPriceByIsbn);
      }
  }
  ```

- 总结：

  - 添加声明式事务管理之后，获取是代理对象，代理对象不能转换为目标对象【实现类】

### Spring声明式事务管理属性

> @Transactional注解属性

- **事务传播行为【Propagation】**

  - 当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。

    - 如：执行事务方法method()1【事务x】之后，调用事务方法method2()【事务y】，此时需要设置method()2方法的事务传播行为。

  - Spring的7种传播行为

  | 传播属性         | 描述                                                         |
  | ---------------- | ------------------------------------------------------------ |
  | **REQUIRED**     | 如果有事务在运行，当前的方法就在这个事务内运行；否则就启动一个新的事务，并在自己的事务内运行。 |
  | **REQUIRES_NEW** | 当前的方法**必须**启动新事务，并在自己的事务内运行；如果有事务正在运行，应该将它挂起。 |
  | SUPPORTS         | 如果有事务在运行，当前的方法就在这个事务内运行，否则可以不运行在事务中。 |
  | NOT_SUPPORTED    | 当前的方法不应该运行在事务中，如果有运行的事务将它挂起       |
  | MANDATORY        | 当前的方法必须运行在事务中，如果没有正在运行的事务就抛出异常。 |
  | NEVER            | 当前的方法不应该运行在事务中，如果有正在运行的事务就抛出异常。 |
  | NESTED           | 如果有事务正在运行，当前的方法就应该在这个事务的嵌套事务内运行，否则就启动一个新的事务，并在它自己的事务内运行。 |

- 图解事务传播行为

  - **REQUIRED**  

  ![image-20230102125650262](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13704/image-20230102125650262.png)

  ```java
  List<String> isbns = new ArrayList<>();
  isbns.add("1001");
  isbns.add("1002");
  service.checkout("li",isbns);
  //一个事务调用另外的事务
  public void checkout(String username, List<String> isbns) {
          for (String isbn:isbns){
              shopService.purchase(username,isbn);
          }
      }
  ```

  这里是默认的REQUIRED行为，及所有的事物都在Checkout这个事物内运行，当有一个事物运行不成功时及整个事物都运行不成功，那么checkout这个事物就是不成功的。

  - 使用场景：去结账时判断余额是否充足，余额不足：一本书都不能卖

  

  - **REQUIRES_NEW**

    ​	![image-20230102125919262](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/13704/image-20230102125919262.png)

  - 使用场景：去结账时判断余额是否充足，余额不足：最后导致余额不足的那本书，不让购买

    这里的行为是REQUIRES_NEW，即在调用当前事务方法的 时候自己本身创建一个新的事务，并且在自己的事务运行，另外的事务就将他挂起，如果自己的成功了就成功，失败了就是失败，这里面每个事务都是独立的。最后再返回到调用他的事务。

- 事务隔离级别【Isolation】

  - 隔离级别概述：一个事务与其他食物之间的隔离等级【1，2，4，8】
  - 隔离等级
    - 读未提交【1】：READ  UNCOMMITTED
      - 存在问题：脏读【读取到了未提交数据】
      - 例子：
        - 即当事务A去操作表book_stock,将书的库存从100===>99此时A还未提交数据，这时并发一个事务B来查询书的库存，这个时候B读到的数据就是99，如果A事务提交失败了，事务回滚，那么库存还是100，这个时候b就读到了脏数据。
    - 读已提交【2】：READ  COMMITTED
      - 存在问题：可能出现不可重复读
        - 事务A进行写的操作，但是事务B读了一次，然后事务C又过了进行一次写的操作这个时候事务B未结束再读的时候数据就不是之前的数据，这个时候就是不可重复读，处理的话就是通过字段上锁的方式即一个事务正在操作的时候，例外一个事务只能等待
    - 可重复读【4】： REPEATABLE READ
      - 存在问题：可能出现幻读
    - 串行化【8】：SERIALIZABLE

- 事务超时：【timeout】

  - 设置事务超时时间，到达指定时间后会强制事务回滚
  - 类型：int, 单位：秒
  - 默认值：-1【未设置超时】

- 事务只读【readonly】

  - 一般事务方法中只有查询操作时，才将事务设置为只读

- 事务回滚【不回滚】 

  - rollbackFor:设置回滚的异常Class
  - noRollbackFOR:设置不回滚异常Class

### 基于XML配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:tx="http://www.springframework.org/schema/tx"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  
            http://www.springframework.org/schema/context
            http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/tx
            http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
            http://www.springframework.org/schema/aop
            http://www.springframework.org/schema/aop/spring-aop-2.5.xsd">
    <!-- 加载properties文件 -->
    <context:property-placeholder location="classpath:c3p0-db.properties" />
    <!-- 配置数据源，读取properties文件信息 -->
    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
        <property name="driverClass" value="${jdbc.driverClass}" />
        <property name="jdbcUrl" value="${jdbc.jdbcUrl}" />
        <property name="user" value="${jdbc.user}" />
        <property name="password" value="${jdbc.password}" />
    </bean>
    <!-- 配置jdbc模板 -->
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource" />
    </bean>
    <!-- 配置dao -->
    <bean id="accountDao" class="com.mengma.dao.impl.AccountDaoImpl">
        <property name="jdbcTemplate" ref="jdbcTemplate" />
    </bean>
    <!-- 配置service -->
    <bean id="accountService" class="com.mengma.service.impl.AccountServiceImpl">
        <property name="accountDao" ref="accountDao" />
    </bean>
    <!-- 事务管理器，依赖于数据源 -->
    <bean id="txManager"
        class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource" />
    </bean>
    <!-- 编写通知：对事务进行增强（通知），需要编写切入点和具体执行事务的细节 -->
    <tx:advice id="txAdvice" transaction-manager="txManager">
        <tx:attributes>
            <!-- 给切入点方法添加事务详情，name表示方法名称，*表示任意方法名称，propagation用于设置传播行为，read-only表示隔离级别，是否只读 -->
            <tx:method name="find*" propagation="SUPPORTS"
                rollback-for="Exception" />
            <tx:method name="*" propagation="REQUIRED" isolation="DEFAULT"
                read-only="false" />
        </tx:attributes>
    </tx:advice>
    <!-- aop编写，让Spring自动对目标生成代理，需要使用AspectJ的表达式 -->
    <aop:config>
        <!-- 切入点 -->
        <aop:pointcut expression="execution(* com.mengma.service.*.*(..))"
            id="txPointCut" />
        <!-- 切面：将切入点与通知整合 -->
        <aop:advisor pointcut-ref="txPointCut" advice-ref="txAdvice" />
    </aop:config>
</beans>
```

## Spring5新特性

| 名称           | 含义                     | 可标注位置                                                   |
| -------------- | ------------------------ | ------------------------------------------------------------ |
| @Nullable      | 可以为空                 | @Target({ElementType.*METHOD*, ElementType.*PARAMETER*ElementType.*FIELD* |
| @NonNull       | 不应为空                 | @Target((ElementType.*METHOD*, ElementType.*PARAMETER*ElementType.*FIELD*) |
| @NonNullFields | 在特定包下的字段不应为空 | @Target(ElementType.*PACKAGE*@TypeQualifierDefault(ElementType.*FIELD* |
| @NonNullApi    | 参数和方法返回值不应为空 | @Target(ElementType.*PACKAGE*)<br/>@TypeQualifierDefault({ElementType.*METHOD*ElementType.*PARAMETER*) |

- @Nullable作用

  - 位置：可以书写再方法&属性上面&参数前面。
  - 作用：表示当前方法或属性**可以为空**，当时属性为空的时候，不会报错

  ### Spring5整合Log4j2

- 导入jar包

  ```xml
  <dependency>
              <groupId>org.apache.logging.1og4j</groupId>
              <artifactId>1og4j-s1f4j-impl</artifactId>
              <version>2.11.2</version>
              <scope>test</scope>
          </dependency>
  ```

- 编写配置文件【log4j2.xml】

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <!--日志级别以及优先级排序: OFF > FATAL > ERROR > WARN > INFO > DEBUG > TRACE > ALL
   Configuration后面的status用于设置1og4j2自身内部的信息输出，可以不设置，当设置成trace时，可以看到1og4j2内部各种详细输出-->
  
  <configuration status="INFO">
      <!--    先定义所有的appender-->
      <appenders>
          <!--输出日志信息到控制台-->
          <console name="Console" target="SYSTEM_OUT">
              <!--控制日志输出的格式-->
              <PatternLayout pattern="%d{yyyy-MM-dd HH:mm:ss.sss} [%t] %-5level%logger{36} - %msg%n"/>
          </console>
      </appenders>
      <!--然后定义1ogger，只有定义了1ogger并引入的appender，appender才会生效-->
      <!--root: 用于指定项目的根日志，如果没有单独指定Logger，则会使用root作为默认的日志输出-->
      <loggers>
          <root level="DEBUG">
              <appender-ref ref="Console"/>
          </root>
      </loggers>
  </configuration>
  ```

### Spring5整合Junit5

- 导入jar包【注意：将Junit4的jar包删除】

  ```xml
  <dependency>
      <groupId>org.springframework</groupId>
      <artifactId>spring-test</artifactId>
      <version>5.3.1</version>
      <scope>test</scope>
  </dependency>
  <!-- Junit5 -->
  <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter-api</artifactId>
      <version>5.7.2</version>
      <scope>test</scope>
  </dependency>
  ```

- 使用注解整合即可

  - 方式1：

    ```java
    @ContextConfiguration("classpath:applicationContext.xml")
    @ExtendWith(SpringExtension.class)
    ```

  - 方式二：

    ```java
    @SpringJUnitConfig(locations = "classpath:applicationContext.xml")
    public class Test1 {}
    ```

    

